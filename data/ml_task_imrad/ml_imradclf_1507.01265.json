{"year": 2015, "cat": "cs.DC", "smpls": [{"orig_sec": "Introduction", "label": "i", "text": "Load balancing is a widely accepted technique for optimization of the computation performance of scientific applications on parallel architectures. Indeed, the intuition suggests that unlike unbalanced applications, the balanced ones do not waste processor cycles on waiting at points of synchronization and data exchange, maximizing this way the utilization of the processors.\n"}, {"orig_sec": "Introduction", "label": "i", "text": "In this paper, we challenge the universality of the load-balancing approach to optimization of the computation performance of parallel applications. First, we try to understand the limitations of the load-balancing approach. We formulate conditions that should be satisfied by the performance profile of an application in order for the application to achieve its best performance via load balancing.\n"}, {"orig_sec": "Introduction", "label": "i", "text": "Then we use a real-life scientific application to demonstrate that its performance profile on a modern parallel architecture does not satisfy these conditions.\nThe application we use implements the Multidimensional Positive Definite Advection Transport Algorithm (MPDATA), which is one of the major parts of the dynamic core of the EULAG geophysical model [1].\nEULAG (Eulerian/semi-Lagrangian fluid solver) is an established numerical model developed for simulating thermo-fluid flows across a wide range of scales and physical scenarios [2], [3]. In particular, it can be used in numerical weather prediction (NWP), simulation of urban flows, areas of turbulence, ocean currents, etc. This solver, originally developed for conventional HPC systems, is currently being re-written for modern HPC platforms. In particular, MPDATA has been recently re-written and optimized for execution on an Intel Xeon Phi coprocessor [4], [5].\n"}, {"orig_sec": "Introduction", "label": "i", "text": "In our experiments, we observe significant deviations of the MPDATA performance profile from the conditions required for applicability of the load-balancing techniques. Based on this observation, we propose a general method of performance optimization of scientific applications through load imbalancing as well as an algorithm that finds the optimal, possibly imbalanced, configuration of a data parallel application on a set of homogeneous processors. This algorithm uses functional performance models of the application [1], [2] to find the partitioning that minimizes its computation time but not necessarily balances the load of the processors. Finally, we apply this algorithm to optimization of MPDATA on Intel Xeon Phi. Experimental results demonstrate that the performance of this carefully optimized load-balanced application can be further improved by 15% using the proposed load-imbalancing method.\n"}, {"orig_sec": "Introduction", "label": "i", "text": "\nFormulation of the conditions that should be satisfied to guarantee that load balancing will minimize the computation time of parallel application.\n\nBuilding the performance profile of a real-life scientific application on a modern HPC platform and demonstration of its significant deviation from the conditions that guarantee that load balancing be a safe technique for performance optimization.\n\nA new optimization method that uses the performance profile for optimization of the application through its imbalancing.\n\nA partitioning algorithm finding the optimal and generally speaking uneven distribution of computations of an application between homogeneous processing units using its functional performance model.\n\nApplication of the proposed partitioning algorithm to optimization of MPDATA on Intel Xeon Phi, resulting in further acceleration of this carefully optimized load-balanced application by up to 15%.\n\n"}, {"orig_sec": "Introduction", "label": "i", "text": "The rest of the paper is structured as follows. Section\u00a0 overviews load-balancing techniques and formulates the conditions when these techniques would minimize the computation time of parallel applications. Section\u00a0 analyzes the performance profile of MPDATA on Intel Xeon Phi and introduces the new approach to minimization of the computation time through load imbalancing. Section\u00a0 introduces a partitioning algorithm for (uneven) distribution of computations between homogeneous processors, minimizing the computation time of the application. Section\u00a0 applies this algorithm to optimization of MPDATA on Xeon Phi. Section\u00a0 presents experimental results, and Section\u00a0 concludes the paper.\n"}, {"orig_sec": "Experimental results", "label": "r", "text": "The performance results presented in this section are obtained for double precision MPDATA computations corresponding to 40 time steps.\nAll the benchmarks are compiled as native executables using the Intel compiler (v.15.0.2), and run on the Intel Xeon Phi 7120P coprocessor.\nTo ensure the reliability of the results, measurements are repeated multiple times, and average execution times are used.\nWe find the confidence interval and stop the measurements if the sample mean lies in the interval with the confidence level 95%.\nWe use Student's t-test, assuming that the individual observations are independent and their population follows the normal distribution.\n"}, {"orig_sec": "Experimental results", "label": "r", "text": "Table REF  includes both theoretical and experimental execution times of MPDATA for the domain of size 240 \u00d7 240 \u00d7 128 .\nThese results are obtained for different configurations of partitioning, including the traditional \"load-balanced\" partitioning (\u0394 m = 0 ) and a range of \"unbalanced\" partitioning for different \u0394 m >0 .\nThe theoretically optimal \u0394 m  returned by Algorithm\u00a0 is equal to 8, which corresponds to the configuration where each odd or even team processes the sub-domain of size 120\u00d7 128\u00d7 128  or 120\u00d7 112\u00d7 128  respectively.\nIn this case, the estimated execution time of 1.386 seconds is very close to the real computation time which is 1.364 seconds.\nAccording to experiments, the shortest execution time is achieved for \u0394 m=9 , when computations take 1.348 seconds.\n<TABLE>"}, {"orig_sec": "Experimental results", "label": "r", "text": "Comparing the experimental and theoretical times, we can see that\nthe accuracy of theoretical prediction is very good, with prediction errors being as small as 2\u22124% .\nIn general, we can identify\ntwo\nmain factors contributing into the prediction error:\n"}, {"orig_sec": "Experimental results", "label": "r", "text": "\nWhile the experimentally built speed functions of teams T\u2080 , T\u2081 , T\u2082  and T\u2083  are not identical, suggesting some degree of their heterogeneity in execution of the MPDATA workload, our theoretical model considers them homogeneous and represents their speed by the average of the real speed functions, which is then used as input to Algorithm\u00a0.\n\nDuring the construction of the speed functions, the speed of a team for problem size n\u00d7 m\u00d7 l  is measured when other teams process in parallel sub-domains of the same size, n\u00d7 m\u00d7 l . However, during the execution of the application in our experiments different teams process sub-domains of slightly different sizes when \u0394 m\u2260 0 .\n\n"}, {"orig_sec": "Experimental results", "label": "r", "text": "Table REF  also demonstrates the performance gain from applying the proposed load-imbalancing optimization.\nFor the imbalanced configurations presented in this table, we notice a better performance than for the load-balanced configuration of the MPDATA decomposition.\nThe largest performance gain is achieved for \u0394 m=9 , giving the speedup of 1.148x.\n<TABLE>"}, {"orig_sec": "Experimental results", "label": "r", "text": "Table REF  complements the results in Table REF  giving experimental execution times of the individual teams.\nWe can clearly see a significant difference between the execution times measured for the odd and even teams when \u0394 m \u2260 0 .\nObviously, this difference is caused by the unbalanced workloads for the odd and even teams.\nHowever, the total execution time is shorter than in the case of balanced workloads (\u0394 m=0 ).\n"}, {"orig_sec": "Experimental results", "label": "r", "text": "Table REF  also shows that the total execution time is always slightly longer than the maximum time among all teams.\nIt is mainly due to the fact that the computation time of every team is measured without the overheads of inter-team synchronization required after each time step.\nIn addition, the results in Table REF  are presented in Figure\u00a0 REF in a graphical form.\n<FIGURE>"}, {"orig_sec": "Experimental results", "label": "r", "text": "Finally, we evaluate the proposed model-based partitioning algorithm for the MPDATA domain of size 480 \u00d7 480 \u00d7 128 .\nAs in the previous case, the application is executed for different configurations of partitioning, for a range of \u0394 m .\nIn this case, however, the theoretically optimal configuration returned by Algorithm\u00a0 is exactly the same as the experimentally optimal one, both achieved when \u0394 m=20 .\nThe prediction errors are also smaller in this case, not exceeding 3% .\nThe experimental execution time for \u0394 m=20  is 5.338 seconds, in comparison with 6.140 seconds for the even partitioning.This allows us to accelerate the MPDATA computations by 1.15 times.\nMoreover, the performance gain is also observed for other unbalanced configurations, but it is smaller than 1.15x.\nThe results of these experiments are included in Table REF .\n<TABLE>"}, {"orig_sec": "Conclusion", "label": "d", "text": "Modern compute nodes are characterized by both the increasing number of (possibly, heterogeneous) processing elements and a high level of complexity of their integration. Various resources such as caches and data links are shared in an hierarchical and non-uniform way. This makes the development of efficient applications for such platforms a very difficult and challenging task. It would be naive to expect that the performance profile of real-life scientific applications on these platforms will always be comfortably nice and smooth to suit traditional load-balancing techniques used for minimization of their computation time. Therefore, new optimization approaches that do not rely on such increasingly unrealistic assumptions are needed.\nThis work has presented one such approach and demonstrated its applicability to optimization of a real-life application on a modern HPC platform.\n"}, {"orig_sec": "Conclusion", "label": "d", "text": "This research was conducted with the financial support of NCN under grant no. UMO-2011/03/B/ST6/03500.\nWe gratefully acknowledge the help and support provided by Jamie Wilcox from Intel EMEA Technical Marketing HPC Lab.\nThis work is partially supported by EU under the COST Program Action IC1305: Network for Sustainable Ultrascale Computing (NESUS).\n"}]}